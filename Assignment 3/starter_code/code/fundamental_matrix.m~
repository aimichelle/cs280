function [F, res_err] = fundamental_matrix(matches)
    % Normalization
    t1_add = [1,0; 0,1; mean(matches(:,1:2))];
    t2_add = [1,0; 0,1; mean(matches(:,3:4))];
    p1 = [matches(:,1:2) ones(size(matches, 1), 1)]*t1_add;
    p2 = [matches(:,3:4) ones(size(matches, 1), 1)]*t2_add;
    std1 = std(p1(:,:));
    std2 = std(p2(:,:));
    p1 = p1 * [std1(1),0; 0,std1(2)];
    p2 = p2 * [std2(1),0; 0,std2(2)];
    
    % Optimization
    % Create A from our normalized matching points
    % There is probably a better way to do this, but I suck with matrices
    A =  zeros(size(matches, 1), 9);
    for n = 1:size(matches, 1)
        A(n,:) = reshape(transpose([p1(n,:), 1])*[p2(n,:), 1], 1, 9);
    end
    % Use SVD to find approximate solution
    [U1,S1,V1] = svd(transpose(A));
    smallest_value = transpose(find(sum(S1(:, 1:9),1) == min(sum(S1(:, 1:9),1))));
    smallest_value = smallest_value(1);
    f = reshape(U(:, smallest_value), 3, 3);
    [U2, S2, V2] = svd(f);
    F = U2 * [S2(1,:);S2(2,:);0,0,0] * V2;
    
    % Denormalization
    
    
    
    
end